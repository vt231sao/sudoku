<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: hooks/useSudokuGame.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: hooks/useSudokuGame.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module Hooks/useSudokuGame
 * @description Головний хук гри, який об'єднує логіку Судоку, управління станом поля, таймер та перевірку перемоги/поразки.
 */

import { useState, useEffect } from 'react';
import { useSettingsStore } from '../store/useSettingsStore';
import { generateSudoku, checkSolution } from '../utils/sudokuLogic';
import { useTimer } from './useTimer';

/**
 * Максимально допустима кількість помилок перед поразкою.
 * @constant {number}
 */
const MISTAKE_LIMIT = 3;

/**
 * Створює порожнє ігрове поле 9x9, заповнене null.
 * @private
 * @returns {Array&lt;Array&lt;null>>} Порожній двовимірний масив.
 */
function createEmptyGrid() {
    return Array(9).fill(null).map(() => Array(9).fill(null));
}

/**
 * Об'єкт, що містить повний стан поточної гри та функції для взаємодії з полем.
 * @typedef {Object} GameState
 * @property {Array&lt;Array&lt;number|null>>} board - Поточне ігрове поле.
 * @property {Array&lt;Array&lt;number|null>>} initialBoard - Початкове поле (для заборони редагування базових цифр).
 * @property {Array&lt;Array&lt;number>>} solvedBoard - Правильно вирішене поле (для перевірки помилок).
 * @property {Array&lt;Array&lt;boolean|null>>} errors - Масив, що вказує, які клітинки заповнені з помилкою.
 * @property {{row: number, col: number}|null} selectedCell - Координати вибраної клітинки.
 * @property {number} mistakes - Поточна кількість зроблених помилок.
 * @property {number} time - Поточний час гри у секундах.
 * @property {boolean} isWin - Прапорець перемоги.
 * @property {boolean} isLose - Прапорець поразки.
 * @property {function(number, number): void} selectCell - Функція для вибору клітинки на полі.
 * @property {function(number|null): void} handleInput - Функція для введення значення у вибрану клітинку.
 */

/**
 * Головний хук управління процесом гри.
 * @returns {GameState} Повний стан гри та методи керування.
 */
export function useSudokuGame() {
    const difficulty = useSettingsStore((state) => state.difficulty);
    const { time, stopTimer } = useTimer(true);

    const [initialBoard, setInitialBoard] = useState(createEmptyGrid());
    const [solvedBoard, setSolvedBoard] = useState(createEmptyGrid());
    const [board, setBoard] = useState(createEmptyGrid());
    const [errors, setErrors] = useState(createEmptyGrid());

    const [selectedCell, setSelectedCell] = useState(null);
    const [mistakes, setMistakes] = useState(0);
    const [isWin, setIsWin] = useState(false);
    const [isLose, setIsLose] = useState(false);

    useEffect(() => {
        const { initial, solved } = generateSudoku(difficulty);
        setInitialBoard(initial);
        setSolvedBoard(solved);
        setBoard(initial);
    }, [difficulty]);

    function selectCell(row, col) {
        setSelectedCell({ row, col });
    }

    function handleInput(value) {
        if (!selectedCell || isWin || isLose) return;

        const { row, col } = selectedCell;

        if (initialBoard[row][col] !== null) {
            return;
        }

        const newBoard = board.map(r => [...r]);
        newBoard[row][col] = value;
        setBoard(newBoard);

        const newErrors = errors.map(r => [...r]);
        let isError = false;

        if (value !== null &amp;&amp; value !== solvedBoard[row][col]) {
            isError = true;
            newErrors[row][col] = true;
            if (board[row][col] !== value) {
                setMistakes(m => m + 1);
            }
        } else {
            newErrors[row][col] = null;
        }
        setErrors(newErrors);

        const currentMistakes = mistakes + (isError &amp;&amp; board[row][col] !== value ? 1 : 0);

        if (currentMistakes >= MISTAKE_LIMIT) {
            stopTimer();
            setIsLose(true);
            setSelectedCell(null);
            return;
        }

        if (checkSolution(newBoard, solvedBoard)) {
            stopTimer();
            setIsWin(true);
            setSelectedCell(null);
        }
    }

    return {
        board,
        initialBoard,
        solvedBoard,
        errors,
        selectedCell,
        mistakes,
        time,
        isWin,
        isLose,
        selectCell,
        handleInput
    };
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Hooks_useSudokuGame.html">Hooks/useSudokuGame</a></li><li><a href="module-Hooks_useTimer.html">Hooks/useTimer</a></li><li><a href="module-Store_Leaderboard.html">Store/Leaderboard</a></li><li><a href="module-Store_Settings.html">Store/Settings</a></li><li><a href="module-SudokuLogic.html">SudokuLogic</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Fri Feb 27 2026 23:29:39 GMT+0200 (за східноєвропейським стандартним часом)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
